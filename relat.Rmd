---
title: "title"
author: "author"
abstract: "abstract"
header-includes:
   - \usepackage[brazil]{babel}
   - \usepackage{bm}
   - \usepackage{float}
geometry: left=1.7cm, right=1.7cm, top=3cm, bottom=3cm
output:
  bookdown::pdf_document2:
editor_options:
  chunk_output_type: console
indent: true


---



```{r setup,include=F}

options(digits=3)  #Arrendodamento
options(scipen=999)
ggplot2::theme_set(ggplot2::theme_minimal()) #Tema dos gráficos produzidos no ggplot2
knitr::opts_chunk$set(echo=F,message=F,warning=F,fig.pos = 'H',fig.align = 'center',fig.width=7.8, fig.height=4.85)
scale_fill_discrete = \(...) ggplot2::scale_fill_brewer(... , palette="Set2") #Fixa a scale do fill dos gráficos do ggplot2

```


# Introdução
```{r}
#Aqui vão códigos em R
library(tidyverse)
library(tidymodels)
library(themis)

df = read_csv('https://raw.githubusercontent.com/AlissonRP/MLG-trab/main/Pokemon.csv') |> 
  select(-`Type 2`, -`#`, -Name, -Total) |> 
  mutate(Legendary = factor(ifelse(Legendary == F, 0, 1)),
         Generation = factor(Generation))
```

# Análise Descritiva

```{r}
#Sim, da pra fazer vários de gráficos nessa seção, porém vamos tentar barras quando for estritamente necessário
# Se aparecer um gráfico de pizza vc é removido desse trabalho
df |> 
  group_by(`Type 1`) |> 
  summarise(HP = mean(HP), n = n())
```


# Análise Preditiva
Vamos aqui utilizar como variável de desfecho a classificação do pokémom, sendo portanto Lendário ou não, vamos testar a saber 3 modelos para predição: Random Forest, Regressão logística e Xgboost. Como métrica de avaliação vamos utilizar a área sobre a curva roc e não a acurácia como erroneamente muitos fazem, pois como vimos, a proporção de pokémons não lendários é `r round(df |> group_by(Legendary) |> count() |> mutate(prop = n/nrow(df)) |> with(prop[1]), 2)`, portanto se os modelos predizerem não lendário para todas observações teremos `r round(df |> group_by(Legendary) |> count() |> mutate(prop = n/nrow(df)) |> with(prop[1]), 2)*100`% de acurácia.

```{r model}
set.seed(42)
df_split = initial_split(df |> select(-`Type 1`), prop = 0.8 , strata = Legendary)
df_train = training(df_split)
df_test = testing(df_split)
df_vf = vfold_cv(df_train, 10, strata = Legendary)
```

```{r}
df_rec1 = df_train |> 
  recipe(Legendary ~.)

df_rf = rand_forest(mode = 'classification', trees = 500) |> 
  set_engine('ranger')

df_rl = logistic_reg() |> 
  set_engine('glm')


```

```{r}
df_work=workflow_set(list(si=df_rec1),
                     list(logistic=df_rl,rf=df_rf),cross=T)
```
```{r}
set.seed(4)
doParallel::registerDoParallel(cores=2)
df_tuner=df_work %>% 
  workflow_map("tune_grid",
               resamples=df_vf,
               grid=15,
               metrics=metric_set(roc_auc),verbose=T)
rank_results(df_tuner,rank_metric = "roc_auc") %>% view()
```



## Regressão Logística

## Random Forest 

## Xgboost





# Análise Inferencial



```{r crfgraph, fig.cap = "Nome da figura"}
plot(rnorm(500))
```

Você faz referência cruzada de figuras assim: Figura \@ref(fig:crfgraph)


# Bibliography



